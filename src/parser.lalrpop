use std::str::FromStr;
use binopadd::BinOpAdd;
use binopsub::BinOpSub;
use binopmul::BinOpMul;
use ast_executor::AstExecutor;
use value::Value;

grammar;

pub Stmts: Vec<Box<AstExecutor>> = {
    Stmt => vec![<>],
    <l:Stmts> <r:Stmt> => {
    	let mut result: Vec<Box<AstExecutor>> = vec![];
	result.extend(l);
	result.push(r);
	result
    }
};

Block: Vec<Box<AstExecutor>> = {
    "{" <s:Stmts> "}" => s
};

Stmt: Box<AstExecutor> = {
    <e:Expr> ";" => e,
    Block => Box::new(<>)
};

Expr: Box<AstExecutor> = {
    <e:Expr> "+" <f:Factor> =>
    	 Box::new(BinOpAdd::new(e, f)),
    <e:Expr> "-" <f:Factor> =>
    	 Box::new(BinOpSub::new(e, f)),
    Factor
};

Factor: Box<AstExecutor> = {
    <f:Factor> "*" <t:Term> =>
    	 Box::new(BinOpMul::new(f, t)),
    <f:Factor> "/" <t:Term> =>
    	 Box::new(BinOpAdd::new(f, t)),
    <f:Factor> "%" <t:Term> =>
    	 Box::new(BinOpAdd::new(f, t)),
    Term
};

Term: Box<AstExecutor> = {
    Num => Box::new(<>),
    Bool => Box::new(<>),
    "(" <Expr> ")"
};

Num: Value = {
     r"-[0-9]+" => Value::Ni8(i8::from_str(<>).unwrap()),
     r"[0-9]+" => Value::Nu8(u8::from_str(<>).unwrap())
};

Bool: Value = {
     r"true" => Value::Bool(true),
     r"false" => Value::Bool(false)
};
